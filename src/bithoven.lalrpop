use std::str::FromStr;
use super::ast::*;

grammar;

pub Bithoven: Bithoven = {
    "pragma" <language: Language> "version" <version: Version> <sc1: SemiColon>
    "pragma" <language2: Language> "target" <target: Target> <sc2: SemiColon>
    <stack: MutlipleStack> "{" <script: Script> "}" => {
        Bithoven {
            pragma: Pragma {
                language, version, target
            },
            input_stack: stack,
            output_script: script,
        }
    }
}

pub Language: String = {
    "bithoven" => "bithoven".to_string(),
}

pub Version: String = {
    <one:UnsignedInteger> <d1:Dot> <two:UnsignedInteger> <d2:Dot> <three:UnsignedInteger> => {
        one.to_string() + &d1 + &two.to_string() + &d2 + &three.to_string()
    }
}

pub Target: Target = {
    "legacy" => Target::Legacy,
    "segwit" => Target::Segwit,
    "taproot" => Target::Taproot,
}

pub Script: Vec<Statement> = {
    <statement:Statement*> => statement,
}

pub MutlipleStack: Vec<Vec<StackParam>> = {
    <stack:Stack*> => stack,
}


pub Stack: Vec<StackParam> = {
    <o: OpenParen> <stack:StackParamList> <c: CloseParen> => stack,
}

// Bitcoin script sig(witness) stack
pub StackParamList: Vec<StackParam> = {
    <first:StackParam> <mut more:MoreStackParams*> => {
        more.reverse();
        more.push(first);
        more
    },
    => vec![], // epsilon production
};
pub StackParam: StackParam = {
    <i:Identifier> <c:Colon> <t:Type> => {
        StackParam {
            identifier: i,
            ty: t,
            value: None,
        }
    },
    <i:Identifier> <c:Colon> <t:Type> <a:Assign> <l:LiteralExpression> => {
        StackParam {
            identifier: i,
            ty: t,
            value: Some(l),
        }
    },
};
pub MoreStackParams: StackParam = <c:Comma> <s:StackParam> => s;

pub Statement: Statement = {
    <IfStatement>,
    <LocktimeStatement>,
    <VerifyStatement>,
    <ExpressionStatement>,
}

// If statement follows semantics of bitcoin OP_(NOT)IF, OP_ELSE...
// reference1: https://bitcoin.stackexchange.com/questions/103844/inner-working-of-op-if-and-op-else
// reference2: https://bitcoin.stackexchange.com/questions/90868/does-bitcoin-script-support-nested-ifs-op-if-or-op-notif-inside-one-another
IfStatement: Statement = {
    "if" <c:Expression0> <b:BlockStatement> => {
        Statement::IfStatement {
            condition_expr: c,
            if_block: b,
            else_block: None,
        }
    },
    "if" <c:Expression0> <b1:BlockStatement> "else" <b2:BlockStatement> => {
        Statement::IfStatement {
            condition_expr: c,
            if_block: b1,
            else_block: Some(b2),
        }
    },
};
BlockStatement: Vec<Statement> = "{" <s:Script> "}" => s;


// Below statements don't produce value(so, not expression), just perform an action.
LocktimeStatement: Statement = <op:LocktimeOp> <operand:UnsignedInteger> <s:SemiColon> => {
    Statement::LocktimeStatement {
        op: op,
        operand: operand as u32
    }
};
// Bitcoin specific language sytax. verify signature against public key
VerifyStatement: Statement = "verify" <e:Expression0> <s:SemiColon> => {
    Statement::VerifyStatement(e)
};

// Allow expression statement
ExpressionStatement: Statement = <e:Expression0> <s:SemiColon> => {
    Statement::ExpressionStatement(e)
};


pub Expression0: Expression = {
    <CompareExpression>,
    <Expression1>,
};

pub Expression1: Expression = {
    <BinaryMathExpression>,
    <Expression2>,
};

pub Expression2: Expression = {
    <UnaryMathExpression>,
    <CryptoExpression>,
    <ByteExpression>,
    <Expression3>,
};

pub Expression3: Expression = {
    <Identifier> => Expression::Variable(<>),
    <BooleanLiteral> => Expression::BooleanLiteral(<>),
    <StringLiteral> => Expression::StringLiteral(<>),
    <NumberLiteral> => Expression::NumberLiteral(<>),
    <o: OpenParen> <e: Expression0> <c: CloseParen> => e,
};

LiteralExpression: LiteralExpression = {
    <BooleanLiteral> => LiteralExpression::BooleanLiteral(<>),
    <StringLiteral> => LiteralExpression::StringLiteral(<>),
    <NumberLiteral> => LiteralExpression::NumberLiteral(<>),
}

// By separating CmpExpr, you can ensure that boolean operators (&&, ||) only operate on boolean values, 
// and arithmetic operators (+, -, *, /) only operate on numeric values.
CompareExpression: Expression = {
    <l:Expression1> <c:BinaryCompareOp> <r:Expression1> => {
        Expression::CompareExpression {
            lhs: Box::new(l),
            op: c,
            rhs: Box::new(r),
        }
    }
}

UnaryMathExpression: Expression = {
    <op:UnaryMathOp> <operand:Expression2> => {
        Expression::UnaryMathExpression {
            op: op,
            operand: Box::new(operand),
        }
    }
};

BinaryMathExpression: Expression = {
    <l:Expression1> <op:InfixBinaryMathOp> <r:Expression2> => {
        Expression::BinaryMathExpression {
            lhs: Box::new(l),
            op: op,
            rhs: Box::new(r),
        }
    },
    <op:PostfixBinaryMathOp> <p1: OpenParen> <l:Expression1> <c: Comma> <r:Expression2> <p2: CloseParen> => {
        Expression::BinaryMathExpression {
            lhs: Box::new(l),
            op: op,
            rhs: Box::new(r),
        }
    }
};

CryptoExpression: Expression = {
    <op:CryptoOp> <operand:Expression2> => {
        Expression::CryptoExpression {
            op: op,
            operand: Box::new(operand),
        }
    },
    <op:CryptoOp> <operand:MultiSigExpression> => {
        Expression::CryptoExpression {
            op: op,
            operand: Box::new(operand),
        }
    }
}

ByteExpression: Expression = {
    <op:ByteOp> <operand:Expression2> => {
        Expression::ByteExpression {
            op: op,
            operand: Box::new(operand),
        }
    }
}

// Below are Token
// Terminal sequence in the context of lexer(tokenizer)

// Unary Ops
UnaryMathOp: UnaryMathOp = {
    "++" => UnaryMathOp::Add, // OP_1ADD
    "--" => UnaryMathOp::Sub, // OP_1SUB
    "negate" => UnaryMathOp::Negate, // OP_NEGATE
    "abs" => UnaryMathOp::Abs, // OP_ABS
    "!" => UnaryMathOp::Not, // OP_NOT
}

// Binary Ops(Minus can be both Unary and Binary)
// 1. infix
InfixBinaryMathOp: BinaryMathOp = {
    "+" => BinaryMathOp::Add, // OP_ADD
    "-" => BinaryMathOp::Sub, // OP_SUB
}
// 2. postfix(Reverse Polish Notation)
PostfixBinaryMathOp: BinaryMathOp = {
    "max" => BinaryMathOp::Max, // OP_MAX
    "min" => BinaryMathOp::Min, // OP_SUB
}

BinaryCompareOp: BinaryCompareOp = {
    "==" => BinaryCompareOp::Equal, // OP_EQUAL
    "!=" => BinaryCompareOp::NotEqual, // OP_EQUAL OP_NOT
    ">"  => BinaryCompareOp::Greater, // OP_GREATERTHAN
    ">=" => BinaryCompareOp::GreaterOrEqual, // OP_GREATERTHANOREQUAL
    "<"  => BinaryCompareOp::Less, // OP_LESSTHAN
    "<=" => BinaryCompareOp::LessOrEqual, // OP_LESSTHANOREQUAL
    "||" => BinaryCompareOp::BoolOr, // OP_LESSTHANOREQUAL
    "&&" => BinaryCompareOp::BoolAnd, // OP_LESSTHANOREQUAL
};

CryptoOp: CryptoOp = {
    "checksig" => CryptoOp::CheckSig, // OP_CHECKSIG
    "sha256" => CryptoOp::Sha256, // OP_SHA256
    "ripemd160" => CryptoOp::Ripemd160, // OP_RIPEMD160
}

ByteOp: ByteOp = {
    "len" => ByteOp::Size, // OP_SIZE
}

LocktimeOp: LocktimeOp = {
    "older" => LocktimeOp::Cltv, // OP_CHECKLOCKTIMEVERIFY
    "after" => LocktimeOp::Csv, // OP_CHECKSEQUENCEVERIFY
}

Assign: String           = "="  => "=".to_string();

// Puctuation
Dot: String = "." => ".".to_string();
Comma: String = "," => ",".to_string();
Colon: String = ":" => ":".to_string();
SemiColon: String = ";" => ";".to_string();
OpenParen: String = "(" => "(".to_string();
CloseParen: String = ")" => ")".to_string();
OpenBrace: String = "{" => "{".to_string();
CloseBrace: String = "}" => "}".to_string();
OpenBracket: String = "[" => "[".to_string();
CloseBracket: String = "]" => "]".to_string();

// Below are terminals(more precisely, output terminals)
// Must be leaf node of AST

Type: Type = {
    "bool" => Type::Boolean,
    "string" => Type::String,
    "number" => Type::Number,
    "signature" => Type::Signature,
}

Identifier: Identifier = <v:r"[a-zA-Z_][a-zA-Z0-9_]*"> => Identifier(v.to_string());

StringLiteral: String = <l:r#""(\\\\|\\"|[^"\\])*""#> => l[1..l.len()-1].into();

BooleanLiteral: bool = {
    "true" => true,
    "false" => false,
}

NumberLiteral: i64 = {
     <p:UnsignedInteger> => p,
    // Unary minus at the Integer level(Precedence of fixed strings exists)
    // LALRPOP prefers to find the longest match first. 
    // After that, if there are two matches of equal length, it prefers the fixed string
    "-" <p:UnsignedInteger> => {
       // Number is 32 bit sign magnitude int, except when used as locktime.
       // To determine whether locktime or not is beyond context-free grammar.
       // Can be addressed when context analysis done
       if p > i32::MAX as i64 {
           panic!("overflow")
       }
       -p
    }
};

UnsignedInteger: i64 = <s:r"[0-9]+"> => {
    let integer = i64::from_str(s).unwrap();
    // Number is 32 bit sign magnitude int, except when used as locktime.
    // To determine whether locktime or not is beyond context-free grammar.
    // Can be addressed when context analysis done
    if integer <= i32::MIN as i64 || integer > u32::MAX as i64 {
        panic!("overflow")
    } else {
        integer
    }
};

// For multi-sig
MultiSigExpression: Expression = {
    <o: OpenBracket> <m:UnsignedInteger> <n:StringLiteralComma*> <c: CloseBracket> => {
        Expression::MultiSigExpression{
            m: m,
            n: n,
        }
    }
};

pub StringLiteralComma: String = <c:Comma> <s:StringLiteral> => s;

pub Comment: () = { 
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
}

// When there's Ambiguities between regular expressions,
// Use a match declaration, which lets you control the precedence between regular expressions.
// A match declaration lets you explicitly give the precedence between terminals
/*
match {
    r"[0-9]+"
} else {
    r"\w+",
    _
}
*/