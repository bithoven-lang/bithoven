use std::str::FromStr;

grammar;

pub Script: Vec<String> = {
    <stmts:Statement*> => stmts
}

pub Statement: String = {
    <d:VarDeclarationStatement> => format!("(let, ({}, {}))", d.0, d.1),
    <e:ExprStatement> => e,
    <i:IfStatement> => format!("(control, {})", <>),
    <b:BlockStatement> => format!("(block, {})", <>),
    <v:VerifyStatement> => format!("(verify, {})", <>),
    <p:PushDataStatement> => format!("(push, {})", <>),
    <a:AfterStatement> => format!("(after, {})", <>),
    <o:OlderStatement> => format!("(older, {})", <>),
}

// No epsilon for Initalizer, don't neet to have Initializer rule
VarDeclarationStatement: (String, String) = "let" <Identifier> "=" <Expr> ";" => (<>).into();
// Need to have expression statement to avoid conflict of shift-reduce
ExprStatement: String = <Expr> ";" => (<>).into();
// If statement follows semantics of bitcoin OP_(NOT)IF, OP_ELSE...
// reference1: https://bitcoin.stackexchange.com/questions/103844/inner-working-of-op-if-and-op-else
// reference2: https://bitcoin.stackexchange.com/questions/90868/does-bitcoin-script-support-nested-ifs-op-if-or-op-notif-inside-one-another
IfStatement: String = "if" <ConditionExpr> <BlockStatement> "else" <BlockStatement> => format!("if {} {} else {}", <>);
BlockStatement: String = "{" <s:Script> "}" => format!("[{}]", &s.join(", "));
// Bitcoin specific language sytax. verify signature against public key
VerifyStatement: String = "verify" <StringLiteral> ";" => (<>).into();
// Bitcoin specific language sytax. push data to stack. can be replaced [].push() later
PushDataStatement: String = "push" <StringLiteral> ";" => (<>).into();
// Bitcoin specific language sytax. OP_CLTV. inspired by miniscript syntax.
AfterStatement: String = "after" <UnsignedInteger> ";" => (<>).to_string();
// Bitcoin specific language sytax. OP_CSV. inspired by miniscript syntax.
OlderStatement: String = "older" <UnsignedInteger> ";" => (<>).to_string();


pub Expr: String = {
    <l:Literal> => l,
    <m:MathExpr> => m.to_string(),
};

// Support both OP_IF and OP_NOTIF
ConditionExpr: bool = {
    "!" "(" <c:CompareExpr> ")" => !c,
    "(" <c:CompareExpr> ")" => c, // to support js like syntax(while redundant)
    <c:CompareExpr> => c,
}


// By separating CmpExpr, you can ensure that boolean operators (&&, ||) only operate on boolean values, 
// and arithmetic operators (+, -, *, /) only operate on numeric values.
CompareExpr: bool = {
    <l:Expr> "==" <r:Expr> => l == r,
    <l:Expr> "!=" <r:Expr> => l != r,
    <l:Expr> ">"  <r:Expr> => l > r,
    <l:Expr> ">=" <r:Expr> => l >= r,
    <l:Expr> "<"  <r:Expr> => l < r,
    <l:Expr> "<=" <r:Expr> => l <= r,
}

MathExpr: i64 = {
    <l:MathExpr> "+" <r:MathTerm> => l + r,
    <l:MathExpr> "-" <r:MathTerm> => l - r,
    <t:MathTerm> => t,  // Important: This allows a Term to be an Expr
};

// Might be redundant as not support multiplication/division
MathTerm: i64 = {
    <f:MathFactor> => f, // Important: This allows a Factor to be a Term
};

MathFactor: i64 = {
     <p:MathPrimary> => p,
    // Unary minus at the Integer level(Precedence of fixed strings exists)
    // LALRPOP prefers to find the longest match first. 
    // After that, if there are two matches of equal length, it prefers the fixed string
    "-" <p:MathPrimary> => {
       // Number is 32 bit sign magnitude int, except when used as locktime.
       // To determine whether locktime or not is beyond context-free grammar.
       // Can be addressed when context analysis done
       if p > i32::MAX as i64 {
           panic!("overflow")
       }
       -p
    }
};

MathPrimary: i64 = {
    <i:UnsignedInteger> => i,
    "(" <e:MathExpr> ")" => e,
};

UnsignedInteger: i64 = <s:r"[0-9]+"> => {
    let integer = i64::from_str(s).unwrap();
    // Number is 32 bit sign magnitude int, except when used as locktime.
    // To determine whether locktime or not is beyond context-free grammar.
    // Can be addressed when context analysis done
    if integer <= i32::MIN as i64 || integer > u32::MAX as i64 {
        panic!("overflow")
    } else {
        integer
    }
};

Identifier: String = <v:r"[a-zA-Z_][a-zA-Z0-9_]*"> => v.into();

Literal: String = {
    "true" => "true".to_string(),
    "false" => "false".to_string(),
    <s:StringLiteral> => s,
}

StringLiteral: String = <l:r#""(\\\\|\\"|[^"\\])*""#> => l[1..l.len()-1].into();

// Bitcoin integer is sign-magnitude integer.
// Don't know need to differentiate yet.
UnaryOp: String = {
    "-" => "-".to_string(),
    "~" => "~".to_string(),
    "!" => "!".to_string(),
}

BinaryAddOp: String = {
    "+"  => "+".to_string(),
    "-"  => "-".to_string(),
}

BinaryRelOp: String = {
    "==" => "!=".to_string(),
    "!=" => "!=".to_string(),
    ">"  => ">".to_string(),
    ">=" => ">=".to_string(),
    "<"  => "<".to_string(),
    "<=" => "<=".to_string(),
    "&&" => "&&".to_string(),
    "||" => "||".to_string(),
}

SymbolTable: String = {
    "if" => "if".to_string(),
    "else" => "else".to_string(),
    "for" => "for".to_string(),
    "in" => "in".to_string(),
    "let" => "let".to_string(),
    "const" => "const".to_string(),
    "static" => "static".to_string(),
    "throw" => "throw".to_string(),
    "function" => "function".to_string(),
    "this" => "this".to_string(),
}

pub Comment: () = { 
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
}

// When there's Ambiguities between regular expressions,
// Use a match declaration, which lets you control the precedence between regular expressions.
// A match declaration lets you explicitly give the precedence between terminals
/*
match {
    r"[0-9]+"
} else {
    r"\w+",
    _
}
*/