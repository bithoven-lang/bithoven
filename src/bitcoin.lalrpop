use std::str::FromStr;

grammar;

pub Script: Vec<String> = {
    <stmts:Statement*> => stmts
}

pub Statement: String = {
    <d:VarDeclarationStatement> => "(".to_owned() + &d.0 + ", " + &d.1 + ")",
    <s:SymbolTable> => s,
    <e:ExprStatement> => e,
}

VarDeclarationStatement: (String, String) = "let" <Identifier> "=" <Expr> ";" => (<>).into();
ExprStatement: String = <Expr> ";" => (<>).into();

pub Expr: String = {
    <l:Literal> => l,
    <m:MathExpr> => m.to_string(),
};

MathExpr: i64 = {
    <l:MathExpr> "+" <r:Term> => l + r,
    <l:MathExpr> "-" <r:Term> => l - r,
    <t:Term> => t,  // Important: This allows a Term to be an Expr
};

Term: i64 = {
    <f:Factor> => f, // Important: This allows a Factor to be a Term
};

Factor: i64 = {
     <i:Integer> => i,
    "(" <e:MathExpr> ")" => e,
};

Integer: i64 = {
     <n:Num> => n,
     // Unary minus at the Integer level(Precedence of fixed strings exists)
     // LALRPOP prefers to find the longest match first. 
     // After that, if there are two matches of equal length, it prefers the fixed string
     "-" <n:Num> => {
        // Number is 32 bit sign magnitude int, except when used as locktime.
        // To determine whether locktime or not is beyond context-free grammar.
        // Can be addressed when context analysis done
        if n > i32::MAX as i64 {
            panic!("overflow")
        }
        -n
     },
}

Num: i64 = <s:r"[0-9]+"> => {
    let integer = i64::from_str(s).unwrap();
    // Number is 32 bit sign magnitude int, except when used as locktime.
    // To determine whether locktime or not is beyond context-free grammar.
    // Can be addressed when context analysis done
    if integer <= i32::MIN as i64 || integer > u32::MAX as i64 {
        panic!("overflow")
    } else {
        integer
    }
};

Identifier: String = <v:r"[a-zA-Z_][a-zA-Z0-9_]*"> => v.into();

Literal: String = {
    "true" => "true".to_string(),
    "false" => "false".to_string(),
    <s:StringLiteral> => s,
}

StringLiteral: String = <l:r#""(\\\\|\\"|[^"\\])*""#> => l[1..l.len()-1].into();


SymbolTable: String = {
    "if" => "if".to_string(),
    "else" => "else".to_string(),
    "for" => "for".to_string(),
    "in" => "in".to_string(),
    "let" => "let".to_string(),
    "const" => "const".to_string(),
    "static" => "static".to_string(),
    "throw" => "throw".to_string(),
    "function" => "function".to_string(),
    "this" => "this".to_string(),
}

pub Comment: () = { 
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
}

// When there's Ambiguities between regular expressions,
// Use a match declaration, which lets you control the precedence between regular expressions.
// A match declaration lets you explicitly give the precedence between terminals
/*
match {
    r"[0-9]+"
} else {
    r"\w+",
    _
}
*/