use std::str::FromStr;

grammar;

pub Expr: i64 = {
    <l:Expr> "+" <r:Term> => l + r,
    <l:Expr> "-" <r:Term> => l - r,
    <t:Term> => t,  // Important: This allows a Term to be an Expr
};

pub Term: i64 = {
    <f:Factor> => f, // Important: This allows a Factor to be a Term
};

pub Factor: i64 = {
     <i:Integer> => i,
    "(" <e:Expr> ")" => e,
};

pub Integer: i64 = {
     <n:Num> => n,
     "-" <n:Num> => -n, // Unary minus at the Integer level
}

Num: i64 = <s:r"[0-9]+"> => {
    let integer = i64::from_str(s).unwrap();
    // Number is 32 bit sign magnitude int, except when used as locktime.
    // To determine whether locktime or not is beyond context-free grammar.
    // Can be addressed when context analysis done
    if integer <= i32::MIN as i64 || integer > u32::MAX as i64 {
        panic!("overflow")
    } else {
        integer
    }
};

pub Var: String = <r"[a-z]"> => <>.chars().next().unwrap().into();

pub Lit: String = <l:r#""[a-z ]*""#> => l[1..l.len()-1].into();

pub Eql: (String, String) = <Var> "=" <Lit> => (<>).into();
/*
pub Comm: () = <> => match <> {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
}
*/